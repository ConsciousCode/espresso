#**
 * Main header for esplib which implements the standard library values.
 *
 * Note that this serves primarily as a dogfooding exercise to iterate on
 *  the syntax and semantics of the core language. This file will very
 *  likely become out of date as time goes on until it's updated.
 *
 * Some more notes about the exercise so far:
 *  - It's unclear how to implement prototypes for builtin values which have
 *     small object optimizations, particularly the constructor
 *
 *  - We will probably need to make some semantics equivalent to Python's
 *     __new__ in order to implement proto
 *     * This also seems to be necessary for implementing spread types
 *     * One possibility is the this keyword could have reference semantics
 *        and invocation of super() automatically sets it
 *     * If we could do this then prototypes can effectively double as
 *        metaobjectes
 *
 *  - Slicing cannot be reasonably implemented as variadic arguments because
 *     it confuses the parameterization of set, which would either need the
 *     the value to be first or to use unpacking like (...index, value). It's
 *     also complicated by the need to distinguish ls[] from ls[:]
 *
 *  - In order to get the GC reallocatable pool optimization we wanted for
 *     list without making it unrepresentable in-language, we need an
 *     equivalent *built-in* type akin to C++'s unique_ptr which I've named
 *     unique[T] for the time being. This allows us to assume that the
 *     reference never has any other owner (disallows passing to impls
 *     without some kind of coercion to shared_ptr and the pointer will
 *     usually need to be a private or even hidden property) and so the
 *     realloc pool can just reference the slot and update it whenever it
 *     gets moved.
 *
 *  - Proxy is an integral primitive for sidestepping the object model
 *     because its members aren't exposed at all, they are substitutes for
 *     the normal operator resolution algorithms. For example, the get
 *     method is called first instead of own properties being searched first
 *     followed by get method backup which is the normal procedure.
 *
 * Builtin value types:
 * * Inline: none delete bool smi float
 * * GC primitives: i8[] i16[] i32[] i64[] f32[] f64[] any[] object[]
 * * Object model primitives: dict object proxy unique
 *
 * 
**#

import iter => *;

###########################
##* Language intrinsics *##
###########################

# These have parser-level support

# none, true, false

#######################
##* Code intrinsics *##
#######################

# These cannot be defined within the language without referencing themselves

function call(this, ...args) {
	if(typeof this == function) {
		asm { (this ...args call __builtin_call) }
	}
	else if(this has "call") {
		call(this.call, ...args);
	}
	else this;
}

function get(this, name) {
	switch(typeof this) {
		case none => none;
		case object => {
			var x = asm { (name call __builtin_get) }
			if(x is undefined) {
				return get(__builtin_proto(this), name);
			}
			else x;
		}
		default:
			get(typeof this, name);
	}
}

function set(this, name, value) {
	switch(typeof this) {
		case none => fail "Setting property \{name} of none";
		case object => {
			var x = asm { (name call __builtin_set) }
			if(x is undefined) {
				
			}
		}
	}
}

export const
	call = __builtin_call,
	get = __builtin_get,
	set = __builtin_set;

export function own(this, name) = __builtin_own(this, name);

export function typeof(this) = __builtin_typeof(this);

export function new(this, ...args) {
	this->(typeof(this).new ?? __builtin_object)(...args)
}

export function delete(this, key) {
	this->(typeof(this).delete ?? __builtin_delete)(key);
}

export function proto(name, this, body) {
	this->(typeof(this).proto)(name, body) ?? new this(body);
}

##########################
##* Fallback operators *##
##########################

# These can be defined without self-referencing but have default behavior
#  that cannot

export function has(name): bool {
	this->(typeof(this).has ?? __builtin_has)(name) as bool;
}

##############
##* Errors *##
##############

#**
 * Base error class
**#
proto Error is class {
	public msg;
	
	init(msg) {
		this.msg = msg;
	}
}

#**
 * Error generated from misuse of a null object
**#
proto NullError is Error {}

#**
 * Error generated by unexpected usage of type
**#
proto TypeError is Error {}

##################
##* Singletons *##
##################

## Protocol signals ##

#**
 * Represents that the value it represents should not exist. For example, a
 *  list comprehension which yields delete should have one less output
**#
export const delete = new proto delete { ??() true }

#**
 * The value of the operation could not be determined via the given
 *  implementation, but its validity could also not be ruled out. This is
 *  used to enable operator overload composition
**#
export const undefined = new proto undefined { ??() true }

#**
 * Type hint that a function never returns.
**#
export const never = new proto never { ??() true }

#**
 * Indication that the value should be whatever the default is, without
 *  knowing that default.
**#
export const default = new proto default {}

#**
 * Use in place of none where you want any usage to be a program error.
**#
export const null = new proto null {
	??() = true;
	
	new() fail new NullError("new");
	get() fail new NullError("get");
	set() fail new NullError("set");
	delete() fail new NullError("delete");
	
	is(lhs, rhs) {
		# Nothing is null by default
		if(this === rhs) false else undefined;
	}
	
	in(lhs, rhs) fail new NullError("in");
	
	# null has nothing
	has(lhs, rhs) false;
	
	as(lhs, rhs) {
		if(this === lhs) {
			# null can be coerced if the rhs implements it
			var x = rhs->operator.as(lhs, rhs)
			if(x is not unknown) return x;
		}
		else {
			if(lhs === rhs) return null;
		}
		
		fail new NullError("\{lhs} as \{rhs}");
	}
	
	call() fail new NullError("call");
}

#########################
##* Keyword operators *##
#########################

# Operators which have no need for intrinsics

#**
* Global `is` operator definition.
**#
export function is(lhs, rhs): bool {
	# Strict equality will always override specializations
	return? lhs === rhs;
	
	# Object knows more about what it is, check it first
	var res = lhs->(typeof(lhs).is)(lhs, rhs);
	if(res !== undefined) return res;
	
	# Otherwise, types know what their instances look like
	res = rhs->(typeof(rhs).is)(lhs, rhs);
	if(res !== undefined) return res;
	
	# All options exhausted, lhs is not rhs
	return false;
}

#**
* Global `as` operator definition.
**#
export function as(lhs, rhs) {
	# Specialized conversions
	var res = lhs->(typeof(lhs).as)(lhs, rhs);
	if(res !== undefined) goto invalid;
	
	# Generic conversions
	res = rhs->(typeof(rhs).as)(lhs, rhs);
	if(res !== undefined) goto invalid;
	
	# Failure to convert is a program error
	fail new TypeError("Failed to convert \{lhs} to \{rhs}");
	
	invalid: fail new TypeError("as returned an invalid type");
}

#**
* Global `in` operator definition.
**#
export function in(lhs, rhs): bool {
	# The container knows how to index its contents
	var res = lhs->(typeof(lhs).in)(lhs, rhs);
	if(res !== undefined) {
		if(res is not bool) {
			fail new TypeError("in operator returned non-boolean");
		}
		else return res;
	}
	
	# Should lhs even have a specialization? What would the use-case be,
	#  some kind of magic key/item that exists in all containers implicitly?
	
	return false;
}

## Functional ##

export const
	#**
	* Floating point quiet Not a Number (NaN).
	**#
	nan = float('nan'),
	
	#**
	* Floating point infinity.
	**#
	inf = float('inf');

########################
##* Value prototypes *##
########################

#*

Naming:
* metaobject = type + value, main example I can think of is `var` which has special semantics
* metatype = object describing a type, examples: class, struct, enum, union, interface

none
prototype
	object
		null
		metaobject
			var = livevar
			heapvar
		metatype
			class
				collection
					array
					tuple
					list
					dict
			struct
			enum
			union
			interface
		Exception
			Warning
				DeprecationWarning
			
			Signal
				OSSignal
			
			Fail # "Couldn't complete the operation"
				SyntaxFail
				ValueFail
				ParseFail
				RangeFail
			
			Error # "The program has a bug"
				ImportError
				OSError
				NameError
				SyntaxError
				ValueError
				TypeError
				LogicError
				AssertError
			
			Fault # "The abstract machine is corrupted"
				StackFault
				MemoryFault
	primitive
		number
			int
				bool
				i8 i16 i32 i64 ...
			real
				f32 f64
			complex
		string
		char is union[string, int]
		function
			method
			coroutine
	symbol
		undefined # Not defined, no planned definition
		unimplemented # Not defined, planned to be
		unknown # Should be a value but there isn't
		delete # Result should be excluded
		break # Stop iterating
*#

proto metatype is object {
	const name = "metatype";
}

proto class is metatype {
	const name = "class";
	
	new(name, body) {
		var _static = {}, _instance = {};
		for(var [key, prop] in body->object.items()) {
			if(prop.static) _static[key] = prop;
			else _instance[key] = prop;
		}
		
		#var [_static, _instance] = body->items->iter.partition(.[0].static)->map(dict);
		
		var type = new object(this) {
			const name,
			const instance: new object(this.instance ?? this) {
				const class, ..._instance
			},
			new(...args) {
				new object(this).init(...args);
				return this;
			},
			..._static
		};
		
		if(type.init is not none) {
			type.init = function [type.init.name](...args) {
				inline type.init(...args);
				return this;
			}
		}
		
		return ...type.init();
	}
	
	call(name, body) new class(name, body);
	proto(name, body) new class(name, body);
	
	is(that) that.class is this;
	has(name) this->object.has(name) or this.instance has name;
	
	|(that) new union[this, that];
}

#**
 * Base class for all metaobjectes
**#
export const metaobject = new object(none) {
	proto: newproto,
	new: newproto,
	in: inhas,
	has: inhas,
	
	is(lhs, rhs) {
		if(this is lhs) undefined else lhs.proto is this;
	},
	
	#**
	* Calling a type is either a constructor or pass through
	**#
	call(...args): this {
		# Pass through an object of the correct type
		if(args.length == 1) {
			if(args[0] is this) {
				return args[0];
			}
		}
		# Create a new one
		new this(...args);
	}
};

#**
 * The default object model maintains two separate prototype chains, the
 *  class chain and the instance chain. The class chain maintains the
 *  metatype, operator overloads for the class itself, and any static
 *  values. The instance chain contains impls and property slot
 *  descriptors.
**#
proto metaobject is none {
	public const name = "metaobject";
	
	proto(name, body, keys=[]) {
		return new this(name, body, keys);
	}
	
	new(name, body, keys=[]) {
		var _static = {}, _instance = {};
		for(var [key, prop] in object.items(body)) {
			if(prop.static) _static[key] = prop;
			else _instance[key] = prop;
		}
		
		return new object(this) {
			name,
			instance: new object(this.instance ?? this) {
				class, ..._instance
			},
			..._static
		};
	}
	
	has(lhs, rhs): bool {
		if(this === rhs) undefined else this.metadata has prop;
	}
	
	in(lhs, rhs) = rhs has lhs;
	
	is(lhs, rhs) = if(this is lhs) undefined else lhs->proto() is this;
	
	as(lhs, rhs): rhs|undefined {
		if(this === lhs) undefined else new rhs(lhs);
	}
	call(value) = value as this;
}

proto object is metaobject {
	static keys() = __builtin_keys();
	static values() = __builtin_values();
	static items() = __builtin_items();
	
	static new(\proto, values) = __builtin_object(\proto, values);
	new(this, values) = __builtin_object(this, values);
}

proto primitive is none {}

proto bool is primitive {
	
}

######################
##* Word operators *##
######################


############################
##* Arithmetic operators *##
############################

# Arithmetic operators are so similar it's best to use a factory
function makeop(op) {
	return function [op](lhs, rhs) {
		var res = lhs->lhs[symbol.proto][op](lhs, rhs);
		if(res !== undefined) return res;
		
		res = rhs->rhs[symbol.proto][op](lhs, rhs);
		if(res !== undefined) return res;
		
		fail new TypeError(
			"Unsupported operand types for \{op}: " +
			"\{typename(lhs)} and \{typename(rhs)}"
		);
	}
}

export const
	\+ = makeop("+"), \- = makeop('-'),
	\* = makeop("*"), \/ = makeop('/'), \% = makeop("%"),
	\** = makeop("**"), \// = makeop('//'), \%% = makeop("%%");

##################
##* Predicates **#
##################

export function nullish(x): bool {
	x === none or x.nullish() as bool;
}

export function callable(x): bool {
	x.call is not none;
}

#**
 * Natural number predicate
**#
export function natural(x) x > 0;

#**
 * Unsigned number predicate
**#
export function unsigned(x) x >= 0;

const impls = new symbol("impls");
export proto method is function {
	private [impls];
	
	init(fn) {
		this[impls] = {};
	}
	
	call(self, ...args) {
		# Exact type matches are the most common and easiest to look up
		var impl = this[impls][args->map(.[\proto])];
		if(impl is not none) {
			return self->impl(...args);
		}
		
		for()
	}
}

export function memo(fn) {
	const cache = {};
	
	return @wrap(fn) function(...args) {
		return cache[args] ??= fn(...args);
	}
}

export struct long {
	digits: ...int;
	
	@method
	+(lhs, rhs) {
		if(this === lhs) 
	}
}

#**
 * Meta types are high level descriptions of types which themselves cannot be
 *  instantiated. This is especially helpful for implementing operator
 *  overloads for type algebra.
**#
export proto type {
	|(lhs, rhs) {
		var types = [];
		
		if(lhs is union) {
			types.push(...lhs.types);
		}
		else types.push(lhs);
		
		if(rhs is union) {
			types.push(...rhs.types);
		}
		else types.push(rhs);
		
		return union[...types];
	}
}

#**
 * Metatype describing a union of multiple types. Types described by this can be
 *  one of the listed types.
**#
export proto union[...T] is metatype {
	private types = T;
	
	is(lhs, rhs): default {
		if(this === lhs) undefined else this.types->some(lhs is .);
	}
	
	as(lhs, rhs): default {
		if(this === lhs) undefined;
		else this.types
			->filter(lhs is .)
			->map(lhs as .)
			->first(. !== undefined) ?? undefined;
	}
}

#* Metatype for inclusive or type algebra? *#

export proto function {
	is(lhs, rhs): bool|undefined {
		if(this === lhs) rhs === \function or undefined
		# Function being used as a predicate
		else this(lhs) as bool;
	}
	
	as(lhs, rhs): rhs {
		if(this === lhs) undefined else this(lhs);
	}
}

export strict function operator.get(this, name) {
	this[name] or if(this has name) this->this.proto::get(name);
}

export proto symbol is proto is class {
	new(x) {
		return new object(symbol.instance) {
			name: x
		};
	}
	
	call(x) {
		return symbol.registry[x] ??= new symbol(x);
	}
	
	==(lhs, rhs) lhs === rhs;
} {
	class.registry: string[] = [];
}

export proto object is primitive {
	new(p, body) {
		return {
			private \proto: p,
			...body
		};
	}
}
#**
 * Common metatype for classes
**#
export proto class is metaobject {
	static const class = this;
};

export proto container is class {
	
}

#**
 * Prototype of low level fixed arrays.
**#
export proto array(T=any) is container {
	private const data: ...T;
	
	bool() !!this.size;
	string() "\{typename(T)}[\{this->map(repr)->join(', ')}]";
	repr() "array[\{typename(T)}]([\{this->map(repr)->join(', ')}])";
	
	get size() gc.sizeof(this)/sys.sizeof(T);
	
	assign(value: T, index: int, len: int) {
		inline sys.memset(this.data, index, value, len);
	}
	move(from, to, len) {
		inline sys.memmove(this.data, from, to, len);
	}
	copy(from, to, len) {
		inline sys.memcpy(this.data, from, to, len);
	}
	realloc(size) {
		inline gc.realloc(this, size);
	}
	
	in(lhs, rhs) {
		if(this is lhs) return undefined;
		for(var e in this) return? e == lhs then false;
	}
	
	for() {
		yield... for(var i in ..this.size) this.data[i];
	}
}

export proto object {
	static strict proto(x) {
		switch(typeof x) {
			case "none" => none;
			case "bool" => bool.instance;
			case "int" => int.instance;
			case "float" => float.instance;
		}
	}
}

export proto primitive is class {}

export proto number is primitive {}

export proto int is number {
	init(value) {
		if(value is none) 0 else value.int();
	}
	
	bool() this !== 0;
	int() this;
	float() {
		switch(typeof this) {
			case "i8" => asm"\{this} flt.convert_i8_s flt.box"
			case "i16" => asm.i16_float(this);
			case "i32" => asm.i32_float(this);
			case "i64" => asm.i64_float(this);
			
			case "object" => {
				if(this is long) {
					var f = 0.0;
					
					for(var digit in this->.digits) {
						f *= 2.0**sizeof(sysint);
						f += digit;
					}
				}
			}
		}
	}
}

export proto bool is int {
	new(value) {
		# ???
	}
	
	bool() this;
	int() if(this) 1 else 0;
	float() if(this) 1.0 else 0.0;
	string() if(this) "true" else "false";
	repr = string;
	
	+(lhs, rhs) {
		if(this is lhs) {
			switch(typeof rhs) {
				case none => lhs;
				case string => lhs.string();
				else => lhs.int() + rhs;
			}
		}
		# lhs didn't implement +
		else {
			switch(typeof lhs) {
				case none => rhs.int();
				else => none;
			}
		}
	}
	
	-(lhs, rhs) {
		if(this is lhs) {
			switch(typeof rhs) {
				case none => lhs;
				else => lhs.int() - rhs;
			}
		}
		else {
			switch(typeof lhs) {
				case none => -lhs.int();
				else => none;
			}
		}
	}
}

#**
 * Standard list type which models a mutable and resizeable list of
 *  elements. Supports complex indexing operations.
**#
export struct list(T=any) is class {
	private data: unique[T[]];
	private _len: int;
	
	static proto view is proxy {
		public (start, stop, step): int;
		
		get(index) {
			index = index*step + start;
			if(index < stop) this[index];
		}
		
		set(index, value) {
			index = index*step + start;
			if(index < stop) {
				this[index] = value;
			}
		}
		
		delete(index) {
			index = index*step + start;
			if(index < stop) delete this[index];
		}
		
		get length() {
			(stop - start)//step;
		}
		
		for() {
			yield... for(var i in ..this.length) this.data[i];
		}
		
		push(...elems) this.insert(stop, ...elems);
		push_front(...elems) this.insert(start, ...elems);
		
		@overload
		pop() this[stop - 1] after delete this[stop - 1];
		@overload
		pop(...elems) this.remove()
		
	}
	
	new(it: iterable|none = none) {
		var sz = it.length ?? 32;
		this.data = new unique[T[]](sz);
		this._len = sz;
	}
	
	get length() this._len;
	get capacity() this.data.length;
	
	bool() !!this.length;
	string() "[\{this->map(repr)->join(', ')}]";
	
	#**
	 * Create a shallow copy of the list.
	**#
	list() {
		var nls = new list[T](this.length);
		nls->.data.copy(this.data, 0, this.length);
		return nls;
	}
	
	@overload
	get() this.list();
	
	#**
	 * Get the element at the given index.
	**#
	@overload
	get(index: int) this.data[index];
	
	#**
	 * Get a sublist
	**#
	@overload
	get(index: slice) {
		const
			start = index.start ?? 0,
			step = index.step ?? 1;
		
		# Constrain stop to be +1 of last valid element
		const stop =
			((index.stop ?? this.length) - start - 1) # Change basis to 0
			//step*step # Strip remainder
			+ start + 1; # Change back to normal basis
		
		new view(this, start, stop, step);
	}
	
	set(index, value) this.data[index] = value;
	
	@overload
	delete() {
		for(var i in ..this.length) {
			this.data[i] = T();
		}
		this._len = 0;
	}
	@overload
	delete(index: int) {
		this.data.move(index[0] + 1, index[0], 1);
		this.data[this._len--] = T();
	}
	
	@overload
	delete(index: slice) {
		
	}
	delete(index) {
		ls[..10] = T();
		
		if(index.length == 0) {
			for(var i in ..this.length) {
				this.data[i] = T();
			}
			this._len = 0;
		}
		else if(index.length == 1) {
			this.data.move(index[0] + 1, index[0], 1);
			this.data[this._len--] = T();
		}
		else if(index.length == 2) {
			this.data.move(index[1], index[0], index[1] - index[0]);
		}
		else if(index.length == 3) {
			var i = index[0];
			for(var )
		}
		delete this.data[index];
	}
	
	in(lhs, rhs) {
		if(this is lhs) return undefined;
		for(var d in this) return? d == value then false;
	}
	
	for() {
		yield... for(var i in ..this.length) this.data[i];
	}
	
	private resize(additional: int): none {
		if(this.length + additional > this.capacity) {
			var sz = this.length + additional;
			sz += sz/2;
			
			this.data.realloc(sz);
		}
	}
	
	push(...elems): this {
		this.resize(elems.length);
		
		var i = this.length;
		for(var i, e in zip(..this.length, elems)) {
			this.data[i++] = e;
		}
		this._len = i;
		
		return this;
	}
	
	push_front(...elems): this {
		this.resize(elems.length);
		this.data.move(0, elems.length, elems.length);
		
		var i = 0;
		for(var e in elems) {
			this.data[i++] = e;
		}
		
		return this;
	}
	
	@overload
	pop(): T {
		this.data[-1] after this.data[--this._len] = T();
	}
	@overload
	pop(count: int and . > 0): T {
		this.data[-count:].list() after this._len -= count;
	}
	
	@overload
	pop_front(): T {
		this.data[0] after this.data.move(1, 0, --this._len);
	}
	pop_front(count: int and . > 0 or none): T {
		this.data[:count].list() after
			this.data.move(count, 0, this.length -= count);
	}
	
	insert(index: int, ...elems): this {
		this.resize(elems.length);
		this.data.move(index, index + elems.length, elems.length);
		this.data.copy(elems, index);
		
		return this;
	}
	
	#**
	 * Replace the sublist [index:index+len] with elems
	**#
	splice(index: int, len: int & . > 0, elems: iterable): this {
		# Offset from old range to new range
		const off = elems.length - len;
		this.resize(off);
		this.data.move(index + len, index + off, this.length - len);
		this.data.copy(elems, index, elems.length);
		
		return this;
	}
}
